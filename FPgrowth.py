# -*- coding: utf-8 -*-
"""IIT2018085_Assignment3

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vqo-or9gov3QRyFRAYTySoaX7I_JwcNr
"""

import pandas as pd
import numpy as np

#here we are reading the data from dataset
excel = pd.read_excel('Online Retail.xlsx')
dataFrame = pd.DataFrame(excel)

#dropping unecessary coloums and clubbing all rows having same invoice number

dataFrame=dataFrame.drop(['StockCode','Quantity','InvoiceDate','UnitPrice','CustomerID','Country'],axis=1)
tdf=dataFrame.pivot_table(index='InvoiceNo',values='Description',aggfunc=lambda x:list(x))

minSupp = 1700 #(on printing modified dataset we have 26000 rows therefore we take minimum support count as 8% of dataset)

# putting each transaction in a list

transaction=[]
transfreq=[]
for item in tdf['Description']:
  transaction.append(item)
  transfreq.append(1)

#Count the frequency of items in the transactional DB

freq={}
for rows in transaction:
  for item in rows:
    if item in freq:
      freq[item]+=1;
    else:
      freq[item]=1

for key in list(freq.keys()):
  if(freq[key]<minSupp):
    del freq[key]

def frequency(x):
  return freq[x]

OrderedTransaction=[]
for trans in transaction:
  tL = []
  for item in trans:
    if item in freq:
      tL.append(item)

  tL=sorted(tL,key=frequency,reverse=True)
  if(len(tL)>0):
    OrderedTransaction.append(tL)

for item in freq:
  freq[item]=[freq[item],None]

# defineing class to build trie (FP TREE)
class TreeNode:
  def __init__(self,itemName,freq,parent):
    self.itemName = itemName
    self.support = freq
    self.parent = parent
    self.children = {} 
    self.next = None
  def increaseSupp(self,freq):
    self.support+=freq

# A recursive function to add all ordered set in trie...

def FPtree(currentNode,item,x):

  if item in currentNode.children: 
    currentNode.children[item].increaseSupp(x)
  
  else:
    newNode = TreeNode(item,x,currentNode)
    currentNode.children[item]=newNode

    if freq[item][1]==None:
      freq[item][1]= newNode

    else:
      ptr = freq[item][1]
      while ptr.next!=None:
        ptr = ptr.next
      ptr.next = newNode

  return currentNode.children[item]



root = TreeNode('NULL',1,None)

for idx,rows  in enumerate(OrderedTransaction):
  currentNode = root
  for item in rows:
    currentNode = FPtree(currentNode,item,transfreq[idx])

#Bulilding conditional pattern base and conditional frequent tree...

def goUpTree(currNode,tL): 
  if currNode.parent!=None: 
    tL.append(currNode.itemName) 
    goUpTree(currNode.parent,tL)

condfreq=[] 
conditionalFrequentTree=[]

for item in freq:
  node = freq[item][1] 
  cnt={}
  while node!=None:
    tL=[] 
    goUpTree(node,tL)
    if(len(tL)>1):
      tL=tL[1:]
      for i in tL:
        cnt[i]=cnt.get(i,0)+freq[item][0] 
    node=node.next
  
  pr=[]
  for key,value in cnt.items():
    if value>=minSupp:
      pr.append(key)
  conditionalFrequentTree.append(pr)

#Genrating Frequent pattern using conditional frequent pattern tree

import itertools

print(" Following are the generated frequent pattern in the fromat\n","#sr number Item Name\n","Generated frequent pattern correspong to the items\n")

count = 1
for item in freq:
  for row in conditionalFrequentTree:
    for k in range(1,len(row)):
       comb = itertools.combinations(row,k)
       lx=[]
       for j in comb:
         lst = list(j)
         lst.append(item)
         lx.append(lst)
       print ("#",count,item)
       count=count+1 
       for items in lx:
         print(items)
       print("\n")
